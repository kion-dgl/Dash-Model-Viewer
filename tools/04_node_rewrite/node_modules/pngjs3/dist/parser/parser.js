'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require('../constants');

var _constants2 = _interopRequireDefault(_constants);

var _crc = require('../crc');

var _crc2 = _interopRequireDefault(_crc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Parser = function () {
  function Parser(options, dependencies) {
    _classCallCheck(this, Parser);

    this._options = options;
    options.checkCRC = options.checkCRC !== false;

    this._hasIHDR = false;
    this._hasIEND = false;

    // input flags/metadata
    this._palette = [];
    this._colorType = 0;

    this._chunks = {};
    this._chunks[_constants2.default.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[_constants2.default.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[_constants2.default.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[_constants2.default.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[_constants2.default.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[_constants2.default.TYPE_gAMA] = this._handleGAMA.bind(this);

    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
  }

  _createClass(Parser, [{
    key: 'start',
    value: function start() {
      this.read(_constants2.default.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    }
  }, {
    key: '_parseSignature',
    value: function _parseSignature(data) {
      var signature = _constants2.default.PNG_SIGNATURE;

      for (var i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error('Invalid file signature, at position ' + i + ': ' + data[i] + ' !== ' + signature[i]));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    }
  }, {
    key: '_parseChunkBegin',
    value: function _parseChunkBegin(data) {

      // chunk content length
      var length = data.readUInt32BE(0);

      // chunk type
      var type = data.readUInt32BE(4);
      var name = '';
      for (var i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }

      //console.log('chunk ', name, length);

      // chunk flags
      var ancillary = Boolean(data[4] & 0x20); // or critical
      //    priv = Boolean(data[5] & 0x20), // or public
      //    safeToCopy = Boolean(data[7] & 0x20); // or unsafe

      if (!this._hasIHDR && type !== _constants2.default.TYPE_IHDR) {
        this.error(new Error('Expected IHDR on beggining'));
        return;
      }

      this._crc = new _crc2.default();
      this._crc.write(new Buffer(name));

      if (this._chunks[type]) {
        return this._chunks[type](length);
      }

      if (!ancillary) {
        this.error(new Error('Unsupported critical chunk type ' + name));
        return;
      }

      this.read(length + 4, this._skipChunk.bind(this));
    }
  }, {
    key: '_skipChunk',
    value: function _skipChunk() /*data*/{
      this.read(8, this._parseChunkBegin.bind(this));
    }
  }, {
    key: '_handleChunkEnd',
    value: function _handleChunkEnd() {
      this.read(4, this._parseChunkEnd.bind(this));
    }
  }, {
    key: '_parseChunkEnd',
    value: function _parseChunkEnd(data) {

      var fileCrc = data.readInt32BE(0);
      var calcCrc = this._crc.crc32();

      // check CRC
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error('Crc error - ' + fileCrc + ' - ' + calcCrc));
        return;
      }

      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    }
  }, {
    key: '_handleIHDR',
    value: function _handleIHDR(length) {
      this.read(length, this._parseIHDR.bind(this));
    }
  }, {
    key: '_parseIHDR',
    value: function _parseIHDR(data) {

      this._crc.write(data);

      var width = data.readUInt32BE(0);
      var height = data.readUInt32BE(4);
      var depth = data[8];
      var colorType = data[9]; // bits: 1 palette, 2 color, 4 alpha
      var compr = data[10];
      var filter = data[11];
      var interlace = data[12];

      // console.log('    width', width, 'height', height,
      //     'depth', depth, 'colorType', colorType,
      //     'compr', compr, 'filter', filter, 'interlace', interlace
      // );

      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error('Unsupported bit depth ' + depth));
        return;
      }
      if (!(colorType in _constants2.default.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error('Unsupported color type'));
        return;
      }
      if (compr !== 0) {
        this.error(new Error('Unsupported compression method'));
        return;
      }
      if (filter !== 0) {
        this.error(new Error('Unsupported filter method'));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error('Unsupported interlace method'));
        return;
      }

      this._colorType = colorType;

      var bpp = _constants2.default.COLORTYPE_TO_BPP_MAP[this._colorType];

      this._hasIHDR = true;

      this.metadata({
        width: width,
        height: height,
        depth: depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & _constants2.default.COLORTYPE_PALETTE),
        color: Boolean(colorType & _constants2.default.COLORTYPE_COLOR),
        alpha: Boolean(colorType & _constants2.default.COLORTYPE_ALPHA),
        bpp: bpp,
        colorType: colorType
      });

      this._handleChunkEnd();
    }
  }, {
    key: '_handlePLTE',
    value: function _handlePLTE(length) {
      this.read(length, this._parsePLTE.bind(this));
    }
  }, {
    key: '_parsePLTE',
    value: function _parsePLTE(data) {

      this._crc.write(data);

      var entries = Math.floor(data.length / 3);
      // console.log('Palette:', entries);

      for (var i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 0xff]);
      }

      this.palette(this._palette);

      this._handleChunkEnd();
    }
  }, {
    key: '_handleTRNS',
    value: function _handleTRNS(length) {
      this.read(length, this._parseTRNS.bind(this));
    }
  }, {
    key: '_parseTRNS',
    value: function _parseTRNS(data) {

      this._crc.write(data);

      // palette
      if (this._colorType === _constants2.default.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error('Transparency chunk must be after palette'));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error('More transparent colors than palette size'));
          return;
        }
        for (var i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }

      // for colorType 0 (grayscale) and 2 (rgb)
      // there might be one gray/color defined as transparent
      if (this._colorType === _constants2.default.COLORTYPE_GRAYSCALE) {
        // grey, 2 bytes
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === _constants2.default.COLORTYPE_COLOR) {
        this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
      }

      this._handleChunkEnd();
    }
  }, {
    key: '_handleGAMA',
    value: function _handleGAMA(length) {
      this.read(length, this._parseGAMA.bind(this));
    }
  }, {
    key: '_parseGAMA',
    value: function _parseGAMA(data) {

      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / _constants2.default.GAMMA_DIVISION);

      this._handleChunkEnd();
    }
  }, {
    key: '_handleIDAT',
    value: function _handleIDAT(length) {
      this.read(-length, this._parseIDAT.bind(this, length));
    }
  }, {
    key: '_parseIDAT',
    value: function _parseIDAT(length, data) {

      this._crc.write(data);

      if (this._colorType === _constants2.default.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error('Expected palette not found');
      }

      this.inflateData(data);
      var leftOverLength = length - data.length;

      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    }
  }, {
    key: '_handleIEND',
    value: function _handleIEND(length) {
      this.read(length, this._parseIEND.bind(this));
    }
  }, {
    key: '_parseIEND',
    value: function _parseIEND(data) {

      this._crc.write(data);

      this._hasIEND = true;
      this._handleChunkEnd();

      if (this.finished) {
        this.finished();
      }
    }
  }]);

  return Parser;
}();

exports.default = Parser;