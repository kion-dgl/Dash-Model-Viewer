'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PNG = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stream = require('stream');

var _stream2 = _interopRequireDefault(_stream);

var _parser = require('./parser');

var _packer = require('./packer');

var _pngSync = require('./png-sync');

var PNGSync = _interopRequireWildcard(_pngSync);

var _propData = require('./propData');

var propData = _interopRequireWildcard(_propData);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// $FlowFixMe
var PNG = exports.PNG = function (_Stream) {
  _inherits(PNG, _Stream);

  function PNG() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PNG);

    var _this = _possibleConstructorReturn(this, (PNG.__proto__ || Object.getPrototypeOf(PNG)).call(this, options));

    var width = options.width,
        height = options.height,
        initGrayscaleData = options.initGrayscaleData,
        initPropData = options.initPropData;

    // coerce pixel dimensions to integers (also coerces undefined -> 0):

    _this.width = width || 0;
    _this.height = height || 0;

    _this._configPostParse = { initGrayscaleData: initGrayscaleData, initPropData: initPropData };

    _this.data = _this.width > 0 && _this.height > 0 ? new Buffer(4 * _this.width * _this.height) : null;

    if (options.fill && _this.data) {
      _this.data.fill(0);
    }

    _this.gamma = 0;
    _this.readable = _this.writable = true;

    _this._parser = new _parser.ParserAsync(options);

    _this._parser.on('error', _this.emit.bind(_this, 'error'));
    _this._parser.on('close', _this._handleClose.bind(_this));
    _this._parser.on('metadata', _this._metadata.bind(_this));
    _this._parser.on('gamma', _this._gamma.bind(_this));
    _this._parser.on('parsed', function (data) {
      this.data = data;

      this._postParsed();
      this.emit('parsed', data);
    }.bind(_this));

    _this._packer = new _packer.PackerAsync(options);
    _this._packer.on('data', _this.emit.bind(_this, 'data'));
    _this._packer.on('end', _this.emit.bind(_this, 'end'));
    _this._parser.on('close', _this._handleClose.bind(_this));
    _this._packer.on('error', _this.emit.bind(_this, 'error'));

    _this._postParsed = _this._postParsed.bind(_this);
    return _this;
  }

  _createClass(PNG, [{
    key: '_postParsed',
    value: function _postParsed() {
      this._grayscaleData = undefined;
      this._propData = undefined;
      var _configPostParse = this._configPostParse,
          initGrayscaleData = _configPostParse.initGrayscaleData,
          initPropData = _configPostParse.initPropData;

      if (initGrayscaleData) {
        this.initGrayscaleData();
      }
      if (initPropData) {
        var _shrinkMin = initPropData.shrinkMin || false;
        var _shrinkMax = initPropData.shrinkMax || false;
        this.initPropData(_shrinkMin, _shrinkMax);
      }
    }
  }, {
    key: 'pack',
    value: function pack() {
      if (!this.data || !this.data.length) {
        this.emit('error', 'No data provided');
        return this;
      }

      process.nextTick(function () {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));

      return this;
    }
  }, {
    key: 'parse',
    value: function parse(data, callback) {
      if (callback) {
        var onParsed = void 0,
            onError = void 0;

        onParsed = function () {
          this.removeListener('error', onError);

          callback(null, this);
        }.bind(this);

        onError = function (err) {
          this.removeListener('parsed', onParsed);

          callback(err, null);
        }.bind(this);

        this.once('parsed', onParsed);
        this.once('error', onError);
      }

      this.end(data);
      return this;
    }
  }, {
    key: 'write',
    value: function write(data) {
      this._parser.write(data);
      return true;
    }
  }, {
    key: 'end',
    value: function end(data) {
      this._parser.end(data);
    }
  }, {
    key: '_metadata',
    value: function _metadata(metadata) {
      var width = metadata.width,
          height = metadata.height,
          color = metadata.color,
          depth = metadata.depth;

      this.width = width;
      this.height = height;
      this.color = color;
      this.depth = depth;

      this.emit('metadata', metadata);
    }
  }, {
    key: '_gamma',
    value: function _gamma(gamma) {
      this.gamma = gamma;
    }
  }, {
    key: '_handleClose',
    value: function _handleClose() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit('close');
      }
    }

    // eslint-disable-next-line max-params

  }, {
    key: 'bitblt',
    value: function bitblt(src, dst) {
      var srcX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var srcY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var width = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var height = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var deltaX = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var deltaY = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;

      // coerce pixel dimensions to integers (also coerces undefined -> 0):

      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error('bitblt reading outside image');
      }

      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error('bitblt writing outside image');
      }

      var data = src.data;

      if (!data) {
        throw new Error('No data available in src');
      }
      var outData = dst.data;

      if (!outData) {
        throw new Error('No data available in dst');
      }

      for (var y = 0; y < height; y++) {
        data.copy(outData, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }

      return this;
    }
  }, {
    key: 'adjustGamma',
    value: function adjustGamma(src) {
      if (src.gamma) {
        var data = src.data;

        if (!data) {
          throw new Error('No data available for object');
        }

        for (var y = 0; y < src.height; y++) {
          for (var x = 0; x < src.width; x++) {
            var idx = src.width * y + x << 2;

            for (var i = 0; i < 3; i++) {
              var sample = data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.data = data;
        src.gamma = 0;
      }
      return this;
    }
  }, {
    key: 'initGrayscaleData',
    value: function initGrayscaleData() {
      var data = this.data;

      if (!data) {
        throw new Error('The initGrayscaleData() called before receiving data');
      }

      var destLen = data.length / 4;
      var outData = void 0;
      if (this.depth <= 8) {
        outData = new Uint8Array(destLen);
      } else {
        outData = new Uint16Array(destLen);
      }
      if (this.color) {
        var mono = function mono(_ref) {
          var red = _ref.red,
              green = _ref.green,
              blue = _ref.blue;
          return 0.2125 * red + 0.7154 * green + 0.0721 * blue;
        };
        for (var i = 0; i < outData.length; i += 1) {
          var pxPos = i * 4;
          outData[i] = mono({
            red: data[pxPos + 0],
            green: data[pxPos + 1],
            blue: data[pxPos + 2]
          });
        }
      } else {
        outData = data.filter(function (clr, i) {
          return i % 4 === 0;
        });
      }

      this._grayscaleData = outData;
    }

    // Retrieve mono data without aplpha channel

  }, {
    key: 'grayscaleData',
    value: function grayscaleData() {
      var data = this.data;

      if (!data) {
        throw new Error('Invalid call - no data to convert');
      }

      if (!this._grayscaleData) {
        this.initGrayscaleData();
      }

      return this._grayscaleData;
    }
  }, {
    key: 'initPropData',
    value: function initPropData() {
      var shrinkMin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var shrinkMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.color) {
        var data = this.data;

        if (!data) {
          throw new Error('No data to init proportions for');
        }

        this._propData = propData.color(data, shrinkMin, shrinkMax, {
          width: this.width,
          height: this.height,
          depth: this.depth
        });
      } else {
        var _data = this.grayscaleData();
        if (!_data) {
          throw new Error('No data to init proportions for');
        }

        this._propData = propData.grayscale(_data, shrinkMin, shrinkMax, {
          width: this.width,
          height: this.height,
          depth: this.depth
        });
      }
    }

    // Retrieve colors as proportions instead of integers
    // if you want to limit the max proporiton to the bufferEqual
    // max/min value then set the shrinkMax/shrinkMin.

  }, {
    key: 'propData',
    value: function propData() {
      var shrinkMin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var shrinkMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var data = this.data;

      if (!data) {
        throw new Error('Invalid call - no data to convert');
      }

      if (!this._propData) {
        this.initPropData(shrinkMin, shrinkMax);
      }

      return this._propData;
    }

    // Move propData into a threshold clmaped outData

  }, {
    key: 'propData2ImageClamped',
    value: function propData2ImageClamped(clampedDataArray) {
      var lowerThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var upperThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 255;

      if (lowerThreshold < 0) {
        throw new Error('Invalid lower threshold, can\'t be less than 0');
      }

      if (lowerThreshold > upperThreshold) {
        throw new Error('lower threshold should be below the upper threshold');
      }

      var pData = this.propData();
      if (!pData) {
        throw Error('No propData');
      }

      var inflateBy = maxValue / (1 - lowerThreshold - (1 - upperThreshold));
      if (clampedDataArray.length === pData.length) {
        for (var pos = 0; pos < pData.length; pos += 1) {
          if ((pos + 1) % 4 === 0) {
            clampedDataArray[pos + 3] = 255; // Alpha channel
          } else {
            var clr = (pData[pos] - lowerThreshold) * inflateBy;
            clampedDataArray[pos] = clr;
          }
        }
      } else if (clampedDataArray.length === pData.length * (4 / 3)) {
        for (var i = 0; i < pData.length; i += 1) {
          var _pos = i * 4;
          var propPos = i * 3;
          clampedDataArray[_pos] = (pData[propPos] - lowerThreshold) * inflateBy;
          clampedDataArray[_pos + 1] = (pData[propPos + 1] - lowerThreshold) * inflateBy;
          clampedDataArray[_pos + 2] = (pData[propPos + 2] - lowerThreshold) * inflateBy;
          clampedDataArray[_pos + 3] = 255; // Alpha channel
        }
      } else if (clampedDataArray.length === pData.length * 4) {
        for (var _i = 0; _i < pData.length; _i += 1) {
          var _pos2 = _i * 4;
          var _clr = (pData[_i] - lowerThreshold) * inflateBy;
          clampedDataArray[_pos2] = _clr;
          clampedDataArray[_pos2 + 1] = _clr;
          clampedDataArray[_pos2 + 2] = _clr;
          clampedDataArray[_pos2 + 3] = 255; // Alpha channel
        }
      } else {
        throw new Error('Invalid buffer lenghts, expected ' + clampedDataArray.length + ' but got ' + pData.length);
      }
      return clampedDataArray;
    }
  }]);

  return PNG;
}(_stream2.default);

PNG.sync = PNGSync;